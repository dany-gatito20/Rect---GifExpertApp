{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchGifs.js","GifExpertApp.js","index.js"],"names":["AddCategory","categorias","setCategorias","useState","inputValue","setInputValue","onSubmit","e","preventDefault","trim","length","type","value","onChange","target","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","GifGridItem","className","src","alt","GifGrid","loading","state","setState","useEffect","then","imgs","setTimeout","useFetchGifs","GifExpertApp","ReactDOM","render","document","getElementById"],"mappings":"mMAQaA,EAAc,SAAC,GAAiC,IAAhCC,EAA+B,EAA/BA,WAAYC,EAAmB,EAAnBA,cAGrC,EAAoCC,mBAAS,IAA7C,mBAAOC,EAAP,KAAmBC,EAAnB,KAsBA,OAEI,cADA,CACA,QAAMC,SAbW,SAAEC,GACnBA,EAAEC,iBAGGJ,EAAWK,OAAOC,OAAS,IAC5BR,EAAc,CAAEE,GAAH,mBAAkBH,KAE/BI,EAAc,MAMlB,eACI,uBACIM,KAAK,OACLC,MAAOR,EACPS,SAzBc,SAAEN,GACxBF,EAAcE,EAAEO,OAAOF,c,+BCRlBG,EAAO,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DAMbC,EANa,iDAMoCC,UAAWH,GAN/C,+DAQAI,MAAOF,GARP,cAQbG,EARa,gBASEA,EAAKC,OATP,uBASZC,EATY,EASZA,KAIDC,EAAOD,EAAKE,KAAK,SAAAC,GACnB,MAAO,CACHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MACXV,IAAKQ,EAAIG,OAAOC,iBAAiBZ,QAjBtB,kBAqBZM,GArBY,4CAAH,sDCDPO,EAAc,SAAC,GAAkB,IAAjBH,EAAgB,EAAhBA,MAAOV,EAAS,EAATA,IAEhC,OACI,sBAAKc,UAAU,8CAAf,eACI,qBAAKC,IAAMf,EAAMgB,IAAMN,IAD3B,KAEI,kCAAMA,EAAN,OAFJ,SCAKO,EAAU,SAAC,GAAkB,IAAhBnB,EAAe,EAAfA,SAItB,ECJwB,SAAEA,GAG1B,MAA0Bb,mBAAS,CAC/BoB,KAAM,GACNa,SAAS,IAFb,mBAAOC,EAAP,KAAcC,EAAd,KAiCA,OApBAC,qBAAW,WAIPxB,EAASC,GACJwB,MAAM,SAAAC,GAEHC,YAAY,WAERJ,EAAS,CACLf,KAAMkB,EACNL,SAAS,MAGd,UAIZ,CAACpB,IAEGqB,EDhC0BM,CAAc3B,GAAlCa,EAAb,EAAQN,KAAaa,EAArB,EAAqBA,QAYrB,OACI,qCACI,mCAAOpB,EAAP,OADJ,KAGMoB,GAAW,mBAAGJ,UAAU,mCAAb,yBAGb,sBAAKA,UAAU,YAAf,eAGQH,EAAOJ,KAAK,SAAAC,GAAG,OACX,aADkB,CACjB,EAAD,eAESA,GADCA,EAAIC,cEzBzBiB,EAAe,WAOxB,MAAoCzC,mBAAS,CAAC,gBAA9C,mBAAOF,EAAP,KAAmBC,EAAnB,KAQA,OACI,cADM,CACN,iBACI,gDADJ,KAGI,cAAC,EAAD,CACIA,cAAiBA,EACjBD,WAAcA,IAGlB,uBAMA,oCA0BQA,EAAWwB,KAAK,SAAAT,GAAQ,OACpB,aAD2B,CAC1B,EAAD,CAEIA,SAAWA,GADLA,SA1C1B,S,MCrBR6B,IAASC,OACP,cAAC,EAAD,IACAC,SAASC,eAAe,W","file":"static/js/main.0fff6323.chunk.js","sourcesContent":["\r\n// AddCategory: en la carpeta de 'components' creamos este archivo donde estructuramos el componente de agregar una nueva Categoria\r\n// este archivo guarda la estructura para el formulario de busqueda\r\n\r\nimport { useState } from 'react';  // traemos el hook de estado desde React\r\nimport PropTypes from 'prop-types';  // importamos las PropTypes\r\n\r\n// creamos nuestra funcion principal\r\nexport const AddCategory = ({categorias, setCategorias}) => {  // recibimos los elementos que mandamos desde el componente 'GifExpertApp'\r\n\r\n    // en el hook de stado, metemos su estado inicial que tendra el input, en este caso su tecto 'Buscar...'\r\n    const [inputValue, setInputValue] = useState('');  // cuando no tenemos nada que guardar en el 'state', es muy recomendable ponerle un espacio en blanco, si no tiene nada, sera error\r\n\r\n    // creamos una funcion de flecha para cuando se haga un cambio dentro del input, en este caso cuando se modifique el 'state', 'Buscar...'\r\n    const handleInputChange = ( e ) => {  // e = event, el evento que se esta disparando\r\n        setInputValue(e.target.value);\r\n        // para el cambio del estado ('setState') 'setInputValue' le enviamos la referencia de un objeto del 'input' atravez del 'e.target'\r\n        // enviamos el 'value' que es una referencia del valor que tiene el 'input'\r\n    }\r\n\r\n    // creamos una funcion de flecha para quitar el refresh de la pagina, osea que no vuelva a recargar la pagina cuando guardo cambio en ella,\r\n    // sino que se quede en la pagina y ahi mismo solo recarge el componente que tubo cambios.\r\n    const handleSubmit = ( e ) => {  // mandamos el 'e' ('evento')\r\n        e.preventDefault();  // a este evento mandamos 'preventDefault', es para prevenir por default el refresh de la pagina que no queremos que pase\r\n\r\n        // realizamos una validacion para decir que para buscar una categoria en el 'input', no debe guardar espacios en blanco al inicio, y que debe ser mayor a dos letras\r\n        if ( inputValue.trim().length > 2 ) {  // si cumple con lo anterior, entonces hara lo siguiente:\r\n            setCategorias( [inputValue, ...categorias ] );  // cuando se agrega una nueva categoria en el input (setCategorias), agregamos las demas categorias '...categorias'\r\n                                                           // y despues se colocara el nuevo valor que agregamos en el input.\r\n            setInputValue('');  // cuando se guarde la nueva categoria, al dar 'enter' en el input, en automatico se quitara y se pondra un espacio vacio para que coloques otra categoria\r\n        }\r\n    }\r\n\r\n    return (\r\n        // la etiqueta 'form' es para la estructura de formularios; dentro de la etiqueta estructuramos todo lo necesario para nuestro formulario\r\n        <form onSubmit={ handleSubmit }>  {/* la funcion 'onSubmit' funciona para guardar los cambios que sufra todo el formulario */}\r\n            <input\r\n                type=\"text\"\r\n                value={inputValue}  // el 'value' es el valor que tendra la caja de texto 'input', en este caso sera el valor guardado del 'inputValue' que es el texto 'Buscar...'\r\n                onChange={handleInputChange}\r\n                // el 'onChange' funciona para que cuando se realize un cambio a nuestra caja de texto ('input') se guarde los cambios modificando el valor ('value') \r\n            />\r\n        </form>\r\n    )\r\n\r\n} // termina la funcion principal\r\n\r\n// con las 'propTypes' decimos que 'categorias' y 'setCategorias' deben ser requeridas en este componente.\r\nAddCategory.propTypes = {\r\n    setCategorias: PropTypes.func.isRequired,\r\n    categorias: PropTypes.array.isRequired\r\n}","\r\n// creamos una carpeta en el SRC, esta carpeta se llamara 'helpers', este carpeta es solo para funciones que tienen una funcion en especifico y regresaran algo para el componente.\r\n// dentro de esta, creamos un componente llamado 'getGifs' el cual es una funcion asincrona que obtendra y estructurara las imagenes para mostrarlo en el 'HTML'\r\n// identificamos cuando son archivos de funciones porque su primera letra no es capital, si es capital al principio, es porque es un componente\r\n\r\n// creamos una funcion para la peticion 'https' de las imagenes que nosotros buscamos\r\n// mandamos la referencia de las categorias ( category ) y aqui mismo las procesara para mostrarlemas en pantalla\r\nexport const getGifs = async( category ) => {  // como va ser una funcion que tenga procesos algo complejos, debemos a esperarlos a que se ejecuten bien\r\n    // entonces la funcion debe ser async (funcion asincrona) para que estos procesos se ejecuten bien\r\n    // ya una vez ejecutados, la funcion correra con los otros procesos y asi hasta acabar bien\r\n    // como estamos solicitando peticiones http, debemos esperar estos procesos a que se ejecuten bien\r\n\r\n    // en una constante metemos nuestra direccion url donde saldran las imagenes que estemos solicitando\r\n    const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI( category ) }&limit=10&api_key=yADo6UqbOw9UEG2dkZWr6R8hJZePCks0` // concaquetando el 'category' ya asociamos las imagenes con lo que buscamos en el input\r\n                                // 'encodeURL' sirve para que cambie los saltos de linea por simbolos y asi no halla ningun problema a la hora de buscar \r\n    const resp = await fetch( url );  // aqui pedimos la respuesta del url de las imagenes, pero con el 'await' decimos que este proceso se espere hasta ya tenga completamente la respuesta\r\n    const {data} = await resp.json();  // de la data donde sacamos las imagenes, debemos desestructurarala {} y pasar nuestra peticion a cadena de texto con .json\r\n                // con el await debemos eperar a que se ejecute este proceso y una vez concluida seguir con las demas funciones\r\n\r\n    // en otra constante mapeamos los elemntos de nuestras imagenes, las cuales solo sacamos su id, su titulo y su direccion url de las imagenes\r\n    const gifs = data.map( img => {  // llamamos a la constante 'gifs' para mapear las imagenes que se encuantran en la data, las transformamos y las renombramos como 'img'\r\n        return {  // como es una funcion de flecha, regresara lo siguiente\r\n            id: img.id,  // el 'id' de las imagenes, que las encontramos en la direccion de la data, 'img.id'\r\n            title: img.title,  // el 'titulo' de las imagenes que las encontramos en la direccion de la data, 'img.title'\r\n            url: img.images.downsized_medium.url  // la direccion 'url' de las imagenes que las encontramos en la direccion de la data, 'img.images.downsized_medium.url'\r\n        }\r\n    })\r\n\r\n    return gifs;  // terminado este proceso, el resultado lo regresara al componente necesite el resultado\r\n\r\n}  // termina la funcion","\r\n// en este componente estrcturamos como aparecera la imagen y el texto de cada una\r\n\r\n//import React from 'react';\r\n\r\n// creamos la funcion para llamar a la imagen y el nombre que contiene para estructurarlo de como debera aparecer en pantalla\r\nexport const GifGridItem = ({title, url}) => {  // sus argumentos los desetructuramos para sacar solamente el 'title' y el 'url' de las imagenes\r\n\r\n    return (\r\n        <div className=\"card animate__animated animate__fadeInRight\">  {/* dentro de un div apareceran las imagenes */}\r\n            <img src={ url } alt={ title }></img>  {/* para una etiqueta 'img' colocamos la imagen, su src seraa la direccion url y su alt sera el titulo */}\r\n            <p> { title } </p>  {/* en un parrafo metemos el 'title' */}\r\n        </div>\r\n    )\r\n\r\n}  // termina la funcion principa","\r\n// GifGrid, es un componente en el cual solicitaremos la peticion https de las imagenes gifs\r\n\r\nimport { useFetchGifs } from '../hooks/useFetchGifs';  // importamos nuestro Custom hook que creamos para el mensaje de 'Data cargada'\r\n\r\nimport { GifGridItem } from './GifGridItem';  // importamos el componente de 'GifGridItem' donde estructuramos como apareseran las imagenes\r\n\r\n\r\n// creamos la funcion principal del componente\r\nexport const GifGrid = ({ category }) => {  // traemos desde el componente principal las categorias\r\n\r\n    // este 'useEfect' se disparara siempre que nuestea funcion principal cambie el estado 'state', si no se cambia el 'state' entonces solamente se ejecutara una vez hasta que se cambie el 'state'\r\n    //const [images, setImages] = useState([])  // colocamos un hook de 'state', su estado inicial sera un arreglo vacio\r\n    const { data:images, loading } = useFetchGifs( category );  // llamamos al componente de nuestro Custom Hook 'useFetchGifs', su argumento que manejaremos sera el 'loading' que tenemos en el Custom Hook\r\n\r\n    // aqui utilizamos por primera vez el hook de 'useEffect', el cual es una funcion que solamente se ejecutara una sola vez cuando el componente se carge por primera vez\r\n        // con el hook de 'useEffect' nos ayudara a que cierta funcion solo se ejecute cuando se renderiza por primera vez o que cuando cambie su dependencia vuelva a ejecutar esta funcion\r\n    //    useEffect(() => {\r\n    //        getGifs( category )  // quien se cargara solo una vez sera la funcion de 'getGifs'\r\n    //            .then( setImages );  // le enviamos los cambios del estado 'setImages' si esto se ejecuta\r\n    //    }, [ category ])  // este es mi arreglo de dependencias y le mandamos 'category', si llega a cambiar su estado 'category', la funcion se disparara nuevamente porque esta cambio su estado\r\n          // si llegaraa tener un arreglo de dependencias vacio, entonces se ejecutara una sola vez.\r\n\r\n\r\n          //console.log('se renderizo Gif')\r\n    return (\r\n        <>\r\n            <h3> { category } </h3>  {/*mostramos aqui la categoria que nosotros escribamos y busquemos en el 'input'*/}\r\n\r\n            { loading && <p className=\"animate__animated animate__flash\">Cargando...</p> }  \r\n            {/* para el mensaje de 'Cargando...' abrimos una sentencia de JS {} y decimos que si hay un valor diferente al que tiene 'loading', entonces aparecera el mansaje */}\r\n\r\n            <div className=\"card-grid\">  {/* 'className'se refiere a una clase de html en la cual le damos estilos a nuestros componentes */}\r\n\r\n                { // abrimos {} para una sentencia de javascrit\r\n                    images.map( img => (  // mapeamos el arreglo del 'state' 'images', los cuales ahora se nombraran 'img'\r\n                        <GifGridItem  // colocamos el componente de 'gifGridItem' el cual contiene la estructura para presentarse en el html de nuestra aplicacion\r\n                            key={ img.id }  // su lleve 'key' sera el id de las imagenes\r\n                            { ...img }  // para mostrar las imagenes abrimos {} y decimos que despliege todas las imagenes\r\n                        />\r\n                    ) )\r\n                }\r\n\r\n            </div>\r\n        </>\r\n    )\r\n\r\n}  // terminamos la funcion principal","\r\n// creamos una carpeta en el SRC, llamada 'hooks' la cual guardaremos nuestros 'Custom Hooks'\r\n// los 'Custom Hooks' son hooks que nosotros creamos y que podemos modificar para que funcione a nuestra manera\r\n\r\nimport { useEffect, useState } from 'react';  // importamos los hooks del 'useEffect' y 'useState' \r\n\r\nimport { getGifs } from '../helpers/getGifs';  // importamos el componente 'getGifs' donde sacamos la direccion de las imagenes gifs\r\n\r\n// nuestro 'custom hook' lo llamaremos 'useFetchGifs', cuando son custom hooks los nombramos al inicio como \"use...\" y asi identificamos que es un hook\r\nexport const useFetchGifs = ( category ) => {  // mandamos como argumento 'category' donde guardamos las categorias de las imagenes\r\n\r\n    // creamos un estado para el mensaje de carga\r\n    const [state, setState] = useState({\r\n        data: [],  // la 'data' es un arreglo vacio\r\n        loading: true  // el 'loading' sera de valor 'true'\r\n    });\r\n\r\n    //console.log('renderice useFetch')\r\n\r\n    // el 'useEffect' no puede tener una funcion 'Async' (asincrona) que tenga procesos que tarden en ejecutarse, pero se puede realizar con la propiedad '.then' para que sea un proceso 'async'\r\n\r\n    // el hook 'useEffect' es para que cierta funcion queremos que se ejecute una sola vez cuando se carge por primera vez la aplicacion, que nosotros queramos que al cargar la aplicacion\r\n    // cierta informacion o funcion se carge solo la primera vez y no se este ejecutando siempre que se se renderice la aplicacion cuando hay un cambio, por ello utilizamos el 'useEffect'\r\n    // para que esa informacion o funcion solo se realice una vez, solo hasta que cambie su dependencia, se volvera a ejecutar proque cambio su depenedia, si cambia su dependencia,\r\n    // se volvera a ejecutar, pero si no cambia, no se volvera a ejecutar. \r\n    useEffect( () => {\r\n\r\n        //console.log('cambio category')\r\n\r\n        getGifs( category )  // para la funcion llamamos el componente 'getGifs' donde obtenemos la direccion de las imagenes y realizamos la peticion 'https' de las imagenes\r\n            .then( imgs => {  // como es un proceso que debe esperar a ejecutarse, colocamos '.then' ´para que carge las imagenes que necesitamos  // las renombramos como 'imgs'\r\n\r\n                setTimeout( () => {  // realizamos la funcion y el tiempo en que se realizara la funcion, para ello \r\n\r\n                    setState({  // decimos que para el cambio de estado 'setState' los nuevos valores seran los sig:\r\n                        data: imgs,  // la 'data' tendra ahora un arreglo de la imagenes que llamemos desde el 'category' que los renombramos aqui como 'imgs'\r\n                        loading: false  // y el 'loading' cambiara de 'true' a 'false' para mostrar el mensaje de 'Cargando...'\r\n                    });\r\n\r\n                }, 1000)  // el tiempo que tardara en mostrar las siguientes imagenes es de 2 segundos\r\n\r\n            })  // termina la funcion para nuestro 'useEffect'\r\n\r\n    }, [category])  // si cambia la dependencia, la funcion que tenga dentro del 'useEffect', se volvera a ejecutar de nuevo, pero si no cambia, no se ejecutara \r\n\r\n    return state; // { data:[], loading: true };  // retornamos el resultado del state.\r\n\r\n}  // termina la funcion de nuestro custom hook","\r\n// GifExpertApp, nuestra aplicacion principal donde estructuraros todos nuestros componentes\r\n\r\n//import React from 'react';\r\n\r\nimport { useState } from \"react\";  // llamamos el hook de estado desde react\r\n\r\nimport { AddCategory } from \"./components/AddCategory\";  // importamos el componente 'AddCategory' de agregar una nueva categoria\r\n\r\nimport { GifGrid } from \"./components/GifGrid\";\r\n\r\n// creamos nnuestra funcion principal\r\nexport const GifExpertApp = () => {\r\n\r\n    // realizamos un arreglo de elementos para las primeras categorias de nuestra aplicacion\r\n    //const categorias = ['One Punch', 'Samurai X', 'Dragon Ball'];\r\n    // NOTA, recuerda que en tus arreglo NO puedes tener elementos o valores iguales, tienen que ser diferentes a los demas.\r\n\r\n    // con el hook de 'useState' metemos en su estado inicial nuestro arreglo de categorias\r\n    const [categorias, setCategorias] = useState(['Dragon Ball']);\r\n\r\n    // realizamos una funcion para agregar un nuevo elemento a mi arreglo que ya creamos\r\n    //const handleAdd = () => {\r\n        // para el cambio de su estado 'setCategorias' realizamos la sig. funcion\r\n    //    setCategorias([...categorias, 'Hunter X Hunter']);  // colocamos una copia de los elementos anteriores de mi arreglo con el spred ... y al final le colocamos el nuevo elemento\r\n    //}\r\n\r\n    return (  // la funcion principal regresara lo siguiente\r\n        <div>\r\n            <h2>Gif Expert App</h2>  {/* titulo de nuestra Aplicacion */}\r\n\r\n            <AddCategory  // llamamos el componente 'AddCategory' para colocarlo dentro de nuestro componente principal\r\n                setCategorias = {setCategorias}  // mandamos a este componente el 'setCategorias' donde mostramos el nuevo estado de las categorias cuando se realice un cambio\r\n                categorias = {categorias}  // al igual que el 'categorias', para tener referencia de las categorias que tiene el estado\r\n            />\r\n\r\n            <hr />\r\n\r\n            {/*<button onClick={handleAdd}>Agregar</button>*/}\r\n\r\n            {/* para mostrar mi arreglo de categorias en el HTML y que se vean en pantalla realizamos los siguiente: */}\r\n\r\n            <ol>  {/* la etiqueta <ol></ol> es para realizar una lista ordenada */}\r\n\r\n    {/* para crear nuestra lista con los elementos que tengo en mi arreglo de categorias y que se muestren en pantalla realizamos lo sig. */}\r\n\r\n                {   // abrimos llaves {} para hacer la impresion de javascript de mi arreglo de elementos\r\n\r\n                    // llamamos a la categoria a traves de un map, para que regresse cada uno de los valores que tengo en el arreglo\r\n                    // es como si fuera un ciclo, primero regresa en forma de lista la primera categoria que tengo, en este caso 'One Punch'\r\n                    // luego mi siguiente categoria que seria 'Samurai X' y al final la categoria 'Dragon Ball'\r\n                    // en este caso el 'map' me ayudara para sacar cada una de mis categorias del arreglo para asi poder mostrarlos en pantalla\r\n\r\n                    // como creamos un arreglo de elementos, la mejor forma de transformar los elementos de mi arreglo al HTML es atravez del .map\r\n\r\n                    // lo que hace el .map es ir con cada uno de los elementos de mi arreglo y transformarlos en nuevos valores.\r\n\r\n                    // llamamos nuestro arreglo 'categorias', colocamos la funcion .map, \r\n                    //categorias.map( category => (  // ahora los nuevos elementos de mi arreglo los identificaremos con el argumento 'category'\r\n\r\n                        // lo que yo regrese en 'return' sera el nuevo valor que tendra ahora cada uno de los elementos del arreglo\r\n                    //    <li key={ category }>{ category }</li>  // los nuevos elementos que mostraremos en el HTML, por ley pondremos los de 'Category' \r\n                                                                       // porque 'category' contiene los nuevos elementos de mi arreglo\r\n                        // como utilizamos la funcion map, siempre debemos ponerle un 'key'\r\n                        // este key es para que React identifique cual es el elemento que se esta modificando con el map, \r\n\r\n                    //) )\r\n\r\n                    categorias.map( category => (  // aqui pasamos la funcion map que habia creado aca arriba, pero aqui le agregamos un comonente nuevo para obtener los gifs\r\n                        <GifGrid  // llamamos a nuestro componente donde sacaremos las imagenes gifs \r\n                            key={ category }  // este componente necesita el 'key' para identificar las imagenes, por ello se identificaran con las categorias que esten guardadndo\r\n                            category={ category }  // le pasamos a este componente las categorias que se vallan guardando\r\n                        />\r\n                    ) )\r\n                }\r\n\r\n            </ol>  {/* termina nuestra lista ordenada */}\r\n\r\n        </div>\r\n    )\r\n}\r\n\r\n// NOTA: el 'map' es una funcion ASINCRONA ( que no tiene orden ), es muy util cuando utilizamos elementos que no tienen ningun proceso de ejecuion en orden, como lo pueden ser imagenes,\r\n// pero cuando tenemos procesos que deben ejecutarse en un orden y que se espera a su proceso, el 'map' no funciona para esto. La solucion que tenemos es con el ciclo 'for'\r\n// el ciclo 'for' es parecido al 'map', pero este es una funcion SINCRONA ( que tiene un orden a seguir ), esto nos ayuda cuando tenemos elementos que tienen una espera de ejecutarse\r\n// por lo tanto el 'map' para funciones sincronas NO SIRVE, pero funcionan con el 'for'","\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { GifExpertApp } from './GifExpertApp';\n\nimport './index.css';\n\nReactDOM.render(\n  <GifExpertApp />,\n  document.getElementById('root')\n);"],"sourceRoot":""}